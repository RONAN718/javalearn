##jvmGC

堆的GC就像一个公司的管理体系  

年轻代就是实习生和新员工 老年代就是老员工 年轻代和老年代的默认比例是1：2  

年轻代里有新生区和两个存活区比例是8：1 ：1  

一个公司要招一批新的实习生进这个新生区进行锻炼，当这个新生区满的时候就要进行第一次选拔就是我们的ygc  

这时会选出一批合适的实习生（可达的）进入考核区（一个存活区内）其余不合适的实习生（不可达的对象）全部淘汰  

考核中可能出现的情况 :  

1.如果有一个部门的一组实习生们（大对象）都特别优秀，他们便直接晋升为老员工（老年代）  

2.其余的新员工就要经历多次考核晋升为老员工（多次ygc后age达到阈值便可晋升）  

3.今年优秀实习生特别多，新员工不够分配了，那么就给一部分名额直接晋升老员工  

4.公司内部每次选拔都有相关政策进行人员管理（自适应）为了公司更好地发展，年龄限制一直在变化而非定值

正常的轨迹就是
实习生Eden=》新员工（S0和S1之间来回来回）=》老员工（老年区）
特殊情况
实习生=》老员工

到老年代满的时候就会触发公司整体的优化 需要对所有区域进行选拔进行人员变更（FULL GC）

一开始公司使用的是

## 串行GC

每次选拔都要所有人停下手中的活 因为要统一考核不能有差别 整个公司不运转（STOP THE WORLD）然后有一个考核官（一个线程）一个一个员工考核 对于实习生就是记下名字然后安排至相关部门（标记复制）对于老员工就是记下名字然后辞退一些调整部门（标记清除整理）  

这种选举模式导致公司要停止运转一段时间 对于小规模公司还能接受 但是大规模就不能接受了

于是出现了第二种

## 并行GC

公司雇佣了更多的考核官（多个线程）同时来考核员工 使用与之前一样的方案  

这样就可以减少每次公司停止运转的时间（STW）对公司的影响就小了  

后来随着公司业务蒸蒸日上规模更大了  

这一次次的停止运转公司领导不能接受了于是提出了

## CMS GC

这个方案有以下几步构成
阶段 1: Initial Mark（初始标记）  

初始标记的目标是标记所有的 根对象，包括根对象直接引用的对象，以及被年轻代中所 有存活对象所引用的对象（老年代单独回收）。  

需要一个短暂的停止运转因为老板找几个部门的负责人聊聊，这时群龙无首所以需要简短的一个暂停  

阶段 2: Concurrent Mark（并发标记）  

CMS GC 遍历老年代，标记所有的存活对象，从 前一阶段 “Initial Mark” 找到的根对象开始算起。 “并发标 记”阶段，就是与应用程序同时运行，不用暂停的阶段。  

这时每个部门老大回到自己的部门，所以所有项目又可以继续运转，不需要暂停，每个老大开始评估每个手底下的老员工，选择留下来跟他混的手下  

阶段 3: Concurrent Preclean（并发预清理）   

此阶段同样是与应用线程并发执行的，不需要停止应用线 程。 因为前一阶段【并发标记】与程序并发运行，可能 有一些引用关系已经发生了改变。如果在并发标记过程中 引用关系发生了变化，JVM 会通过“Card（卡片）”的方 式将发生了改变的区域标记为“脏”区，这就是所谓的 卡片 标记（Card Marking）  

因为没有停止项目，所以在这过程中可能老大发掘出了某个手下，于是就又记了下来但是与第一批选择的人做了区别标记  

阶段 4: Final Remark（最终标记）   

最终标记阶段是此次 GC 事件中的第二次（也是最后一次）STW 停顿。本阶段的目标是完成老年代中所有存活对象的标记。因为 之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程 序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。 通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件  

中间随着项目的推进，每个人的表现都不一样老大有多次的更改，最终这个季度结束了，老大做了一个最终的决定。  

阶段 5: Concurrent Sweep（并发清除） 

此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此 阶段删除不再使用的对象，并回收他们占用的内存空间  

后续项目推进，但是老大已经提交了最终决定，于是辞退了部分老员工  

阶段 6: Concurrent Reset（并发重置）  

此阶段与应用程序并发执行，重置 CMS 算法相关的内部 数据，为下一次 GC 循环做准备。  

项目继续进行但是考核从未停止只是在等待下一个季度的来临

ParallelGC：1024M/3 = 341.3 M 
CMS：64M * GC线程数4 * 13 / 10 ＝ 332.8M


随着公司发展又有了新的选拔体制

## G1

的全称是 Garbage-First，意为垃圾优先，哪一块的垃圾最 多就优先清理它  

不想CMS只针对老员工 在G1里只要你摸鱼就会被拉出来

首先，堆不再分成年轻代和老年代，而是划分为多个（通常是 2048个）可以存放对象的小块堆区域(smaller heap regions)。 每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来 就是年轻代，所有的 Old 区拼在一起那就是老年代。  

不再按新老员工分而是按部门分 每一个存放对象的小块堆区域就像一个部门  

年轻代模式转移暂停（Evacuation Pause） G1 GC 会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂 停时间。在应用程序刚启动时，G1 还没有采集到什么足够的信息，这时候就处于初始的 fully-young 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区。如果还 没有存活区，则任意选择一部分空闲的内存块作为存活区。 拷贝的过程称为转移（Evacuation)，这和前面介绍的其他年轻代收集器是一样的工作原理。

阶段 1: Initial Mark（初始标记） 此阶段标记所有从 GC 根对象直接可达的对象。   

阶段 2: Root Region Scan（Root区扫描） 此阶段标记所有从 "根区域" 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。   

阶段 3: Concurrent Mark（并发标记） 此阶段和 CMS 的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。   

阶段 4: Remark（再次标记） 和 CMS 类似，这是一次 STW 停顿（因为不是并发的阶段），以完成标记过程。 G1 收集器会短暂地停止应用线程， 停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象。  

阶段 5: Cleanup（清理） 最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升GC 的效率，维护并发标记的内部状态。 所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发的： 例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的 STW 暂停


## 总结
某些情况下 G1 触发了 Full GC，这时 G1 会退化使用 Serial 收集器来完成垃圾的清理工作，它仅仅使用单 线程来完成 GC 工作，GC 暂停时间将达到秒级别的  

1.	并发模式失败  

2.	晋升失败  

3.	巨型对象分配失败


常用的组合为： 
（1）Serial+Serial Old 实现单线程的低延迟 垃圾回收机制  

（2）ParNew+CMS，实现多线程的低延迟垃 圾回收机制  

（3）Parallel Scavenge和Parallel Scavenge Old，实现多线程的高吞吐量垃圾 回收机制

Jdk8默认jvm是  

Parallel ScavengeYoung+Parallel Old的组合
