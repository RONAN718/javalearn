# 多线程和并发编程

## 多线程基础知识

### 为什么要有多线程?

如果把线程看做一个个人力 通过谚语''人多力量大'' 那么多线程就是多个单线程，那么这么多工作力自然（真的会快吗？）工作速度快了

本质原因其实是 摩尔定律的失效 ==》分布式+多核时代降临

| 实际情况                                        | 速率比较                            |
| ----------------------------------------------- | ----------------------------------- |
| 以前所以的硬件性能会按一定频率进行爆发式增长    | 硬件发展速度>应用程序的并发量的增速 |
| 21世纪因为web时代到来应用程序的并发量爆发式增长 | 硬件发展速度<应用程序的并发量的增速 |

#### 内存架构

共享内存架构

所有CPU共享一块内存，导致出现竞争时，总线上传输的数据量就会特别大

非一致性内存访问架构

采用分区分治的方法 两个一组使用内存减少了竞争 适合扩展 通过router进行跨内存访问

#### java线程的创建

![x](C:\Users\16431\Desktop\x.PNG)

Thread.start()在当前主线程里再起一个新线程 实际就是把JavaThread对象转换为真真切切的操作系统的线程对象 

线程的真实资源其实全是在操作系统层面的 JVM实际是通过操作系统的API创建了一个操作系统的线程然后通过管理这个操作系统的生命周期实现了多线程的程序

jvm会为线程分配好相关的栈和工作内存准备好了就会执行这个线程run里的代码逻辑 执行完毕就会终结线程

#### Thread.run和Thread.start的区别

没有start就不会再新建线程那么就如同一个类调自己的方法就不是多线程操作

只有调用了start方法才会真正创建一个操作系统线程进行多线程

#### 进程VS线程

进程是操作系统启动一个程序运行的这样的一个单元 我们看到的pid就是进程号

一个进程含有一个或多个线程 这些线程可以共享这个进程空间里的各项资源

不同进程间使用的资源一般情况是被隔离开的

线程是操作系统调度执行任务的基本单元

现代操作系统其实这个概念越来越模糊了，可以把进程看做一个重量级的线程

## Java的多线程

创建线程的方法本质就是 重写runnable写一个任务然后new 一个Thread或者继承Thread

守护线程 对于jvm进程来说如果当前线程全是守护线程就会将jvm直接终止掉

#### 区分runnable和running

线程先达到一个runnable的状态再去运行，因为cpu分了很多片，多个线程来抢时间片，只有抢到时间片才可以进入running，runnable到running的这个阶段是有操作系统调度控制的与我们的应用程序代码无关

#### Thread类

|             重要属性/方法              |                   说明                    |
| :------------------------------------: | :---------------------------------------: |
|         volatile String name;          |          线程名称--诊断分析使用           |
|         boolean daemon=false;          |             后台守护线程标志              |
|            Runnable target;            |       任务（只能通过构造函数传入）        |
|       synchronized void start()        |         协作启动新线程并自动执行          |
|              void join()               |         协作等待某个线程执行完毕          |
| static native Thread currentThread();  |         静态方法 获取当前线程信息         |
| static native void sleep(long millis); | 静态方法 线程睡眠并让出CPU时间片 不释放锁 |
|              void wait();              |         放弃锁 等待0ms 尝试获取锁         |
|   void wait(long timeout,int nanos);   |    放弃锁 wait 到时间自动唤醒/中途唤醒    |
|    native void wait(long timeout);     |   放弃锁+wait+到时间自动唤醒中途被唤醒    |
|         native void notify();          |          发送信号通知1个等待线程          |
|        native void notifyAll();        |         发送信号通知所有等待线程          |

1.Thread.sleep 一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态 不会释放对象锁，millis后线程自动苏醒进入就绪状态。作用就是给其他线程执行机会的最佳方式

2.Thread.yield 当前线程调用此方法会立刻放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让操作系统再次选择线程

作用就是让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield达到让步目的，该方法于sleep类似但是不能由用户指定暂停多长时间

3.t.join()/t.join(long millis) 当前线程里调用其他线程的join的方法，当前线程进入WAITING/TIMED WAITING状态，当前线程不会释放已经持有的对象锁，因为内部调用了t.wait，所以释放t这个对象上的同步锁 线程t执行完毕或者millis时间到当前线程进入就绪状态。其中，wait操作对应的notify是由jvm底层的线程执行结束前触发的

4.obj.wait() 当前线程调用对象的wait方法。当前线程释放obj对象锁，进入等待队列，依靠notify() notifyAll()唤醒或者wait时间到了自动唤醒，唤醒会自动恢复到wait时的状态

5.obj.notify()唤醒此对象监视器上等待的单个线程，选择是任意的。notifyAll唤醒此对象监视器上的等待的所有线程![捕获](C:\Users\16431\Desktop\捕获.PNG)

RWB

NEW

RUNNING READY

WAITING TIMED-WAITING

BLOCKED

TERMINATED

## 线程安全

多个线程竞争同一个资源时，如果对资源的访问顺序敏感，就称存在竞态条件

导致竞态条件发生的代码区称作临界区

不进行恰当的控制，会导致线程安全问题



可以总结为三种性质 

可见性 当一个共享变量被volatile修饰时，它会保证修改的值会被立刻更新到主内存，当有其他线程需要读取时，它会去内存中读取新值

原子性 这些操作不可被中断的要么执行要么不执行 或者说这个操作不能再被分解为多步操作 只有对基本类型的变量的读取和赋值操作是原子性操作

有序性：java允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性，可以通过volatile关键字来保证一定的"有序性"



happens-before原则 先行发生原则

1.程序次序规则 一个线程内，按照代码先后顺序执行

2.锁定规则 一个unlock操作先行发生于后面对于同一个锁的lock操作

3.volatile变量规则 对一个变量的写操作先行发生于后面对这个变量的读操作

4.传递规则 如果操作A先行发生于操作B 而操作B有先行发生于操作C 则可以得出A先于C

5.线程启动规则 start先于此线程的run

6.线程中断规则 对线程interrupt的方法的调用先行发生于被中断线程的代码检测到中断事件的发生 就是catch要发生在interrupt这个方法之后

7.线程终结规则 线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive的返回值手段能检测到线程已经终止执行

8.对象终结规则 一个对象的初始化完成先行于他的finalize()方法的开始



Synchronized 同步关键字

可以加在对象上 也可以加在一个方法上 也可以加在一块代码上

针对某个对象进行加锁操作（Object monitor） 这个锁加在想要锁的对象头里面的具体的一些标志位上

对象头是由 标记字(1个机器字)+Class指针(1个机器字)+数组长度(int)

![捕获](C:\Users\16431\Desktop\捕获.PNG)

final可以修饰在一个类上 一个方法上 一个局部变量上 一个实例属性上 或者一个静态属性上

| final定义类型    | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| final class XXX  | 不允许继承                                                   |
| final方法        | 不允许override                                               |
| final局部变量    | 不允许修改                                                   |
| final实例属性    | 构造函数/初始化块/init之后不允许更改   只能赋值一次  安全发布:构造函数结束返回时，final域最新的值被保证对其他线程可见 |
| final static属性 | 只能赋值一次 静态块执行后不允许变更                          |

## 线程池